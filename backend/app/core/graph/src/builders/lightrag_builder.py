"""
LightRAG知识图谱构建器

基于LightRAG框架构建知识图谱，支持从文档中自动抽取实体和关系，
并生成GraphML格式的知识图谱文件。
"""
import os
import xml.etree.ElementTree as ET
from typing import Dict, List, Any, Optional, Literal
import logging
from datetime import datetime
from pathlib import Path

from .graph_builder import BaseKnowledgeGraphBuilder
from ..entities import Entity
from ..relations import Relation
from ..graph import KnowledgeGraph
from ..types import EntityType, RelationType
from ..config import Settings

logger = logging.getLogger(__name__)


class LightRAGGraphBuilder(BaseKnowledgeGraphBuilder):
    """LightRAG知识图谱构建器"""
    
    def __init__(self, working_dir: str = "lightrag_storage"):
        super().__init__()
        self.working_dir = Path(working_dir)
        self.rag_instance = None
    
    async def initialize_lightrag(self):
        """初始化LightRAG实例"""
        if self.rag_instance is not None:
            return self.rag_instance
            
        try:
            # 延迟导入LightRAG以避免依赖问题
            from lightrag import LightRAG
            from lightrag.utils import EmbeddingFunc
            from lightrag.llm.openai import openai_embed, openai_complete_if_cache
            from lightrag.kg.shared_storage import initialize_pipeline_status
            
            # 确保工作目录存在
            self.working_dir.mkdir(parents=True, exist_ok=True)
            
            # 创建自定义LLM函数
            async def custom_llm_complete(
                prompt: str,
                system_prompt: str = None,
                history_messages: list = None,
                **kwargs
            ):
                return await openai_complete_if_cache(
                    prompt=prompt,
                    system_prompt=system_prompt,
                    history_messages=history_messages or [],
                    model=Settings.LLM_MODEL,
                    base_url=Settings.OPENAI_API_BASE,
                    api_key=Settings.OPENAI_API_KEY,
                    **kwargs
                )
            
            # 创建自定义嵌入函数
            async def custom_embed(texts: list):
                return await openai_embed(
                    texts,
                    model=Settings.EMBEDDING_MODEL,
                    base_url=Settings.OPENAI_API_BASE,
                    api_key=Settings.OPENAI_API_KEY
                )
            
            # 初始化LightRAG实例
            self.rag_instance = LightRAG(
                working_dir=str(self.working_dir),
                llm_model_func=custom_llm_complete,
                embedding_func=EmbeddingFunc(
                    embedding_dim=Settings.EMBEDDING_DIM,
                    max_token_size=Settings.EMBEDDING_MAX_TOKEN_SIZE,
                    func=custom_embed
                ),
            )
            
            # 重要：两个初始化调用都是必需的！
            await self.rag_instance.initialize_storages()  # 初始化存储后端
            await initialize_pipeline_status()  # 初始化处理管道
            
            logger.info(f"LightRAG initialized with working directory: {self.working_dir}")
            return self.rag_instance
            
        except ImportError:
            logger.error("LightRAG not installed. Please install with: pip install lightrag")
            self.rag_instance = None
            raise
        except Exception as e:
            logger.error(f"Failed to initialize LightRAG: {e}")
            self.rag_instance = None
            raise
    
    async def build_graph(self,
                   texts: List[str] = None, 
                   database_schema: Dict[str, Any] = None,
                   graph_name: str = "lightrag_graph") -> KnowledgeGraph:
        """
        使用LightRAG构建知识图谱
        
        Args:
            texts: 文本列表
            database_schema: 数据库模式（LightRAG不直接支持）
            graph_name: 图谱名称
            
        Returns:
            KnowledgeGraph: 构建的知识图谱
        """
        # 初始化RAG实例
        await self.initialize_lightrag()
        
        if not self.rag_instance:
            raise RuntimeError("LightRAG not initialized")
        
        try:
            logger.info(f"Building knowledge graph with LightRAG: {graph_name}")

            # 处理文本输入
            if texts:
                for i, text in enumerate(texts):
                    logger.info(f"Inserting text document {i+1}/{len(texts)}")
                    # 使用异步版本插入文档
                    await self.rag_instance.ainsert(text)
            
            # 等待LightRAG处理完成并生成GraphML文件
            graphml_file = self.working_dir / "graph_chunk_entity_relation.graphml"
            
            if graphml_file.exists():
                # 从GraphML文件加载知识图谱
                graph = self._load_graph_from_graphml(str(graphml_file), graph_name)
                logger.info(f"Successfully built graph: {len(graph.entities)} entities, {len(graph.relations)} relations")
                return graph
            else:
                logger.warning("GraphML file not generated by LightRAG, creating empty graph")
                return KnowledgeGraph(name=graph_name)
        
        except Exception as e:
            logger.error(f"Error building graph with LightRAG: {e}")
            raise
    
    async def update_graph(self, graph: KnowledgeGraph, 
                    new_entities: List[Entity] = None,
                    new_relations: List[Relation] = None) -> KnowledgeGraph:
        """
        更新知识图谱（LightRAG方式）
        
        Args:
            graph: 现有知识图谱
            new_entities: 新增实体（LightRAG不直接支持）
            new_relations: 新增关系（LightRAG不直接支持）
            
        Returns:
            KnowledgeGraph: 更新后的知识图谱
        """
        logger.warning("LightRAG does not support direct entity/relation updates")
        logger.info("To update the graph, please add new documents using build_graph with texts")
        return graph
    
    async def add_documents(self, documents: List[str], graph_name: str = None) -> KnowledgeGraph:
        """
        添加新文档到现有知识图谱
        
        Args:
            documents: 文档文本列表
            graph_name: 图谱名称
            
        Returns:
            KnowledgeGraph: 更新后的知识图谱
        """
        # 初始化RAG实例
        await self.initialize_lightrag()
        
        if not self.rag_instance:
            raise RuntimeError("LightRAG not initialized")
        
        try:
            logger.info(f"Adding {len(documents)} documents to knowledge graph")
            
            for i, doc in enumerate(documents):
                logger.info(f"Adding document {i+1}/{len(documents)}")
                await self.rag_instance.ainsert(doc)
            
            # 重新加载图谱
            graphml_file = self.working_dir / "graph_chunk_entity_relation.graphml"
            if graphml_file.exists():
                graph = self._load_graph_from_graphml(str(graphml_file), graph_name or "lightrag_graph")
                logger.info(f"Updated graph: {len(graph.entities)} entities, {len(graph.relations)} relations")
                return graph
            else:
                logger.warning("GraphML file not found after adding documents")
                return KnowledgeGraph(name=graph_name or "lightrag_graph")
        
        except Exception as e:
            logger.error(f"Error adding documents: {e}")
            raise
    
    async def search_graph(self, query: str, search_type: Literal["naive", "local", "global", "hybrid"] = "hybrid") -> Dict[str, Any]:
        """
        在知识图谱中搜索
        
        Args:
            query: 查询字符串
            search_type: 搜索类型 ("naive", "local", "global", "hybrid")
            
        Returns:
            Dict[str, Any]: 搜索结果
        """
        # 初始化RAG实例
        await self.initialize_lightrag()
        
        if not self.rag_instance:
            raise RuntimeError("LightRAG not initialized")
        
        try:
            logger.info(f"Searching graph with query: {query}, type: {search_type}")
            
            # 根据搜索类型调用相应的查询方法
            from lightrag import QueryParam
            param = QueryParam(mode=search_type)
            result = await self.rag_instance.aquery(query, param=param)
            
            return {
                "query": query,
                "search_type": search_type,
                "result": result,
                "timestamp": datetime.now().isoformat()
            }
        
        except Exception as e:
            logger.error(f"Error searching graph: {e}")
            raise
    
    async def cleanup(self):
        """
        清理LightRAG资源
        """
        if self.rag_instance:
            try:
                await self.rag_instance.finalize_storages()
                logger.info("LightRAG resources cleaned up")
            except Exception as e:
                logger.error(f"Error during cleanup: {e}")
            finally:
                self.rag_instance = None
    
    def _load_graph_from_graphml(self, graphml_file: str, graph_name: str) -> KnowledgeGraph:
        """
        从GraphML文件加载知识图谱
        
        Args:
            graphml_file: GraphML文件路径
            graph_name: 图谱名称
            
        Returns:
            KnowledgeGraph: 加载的知识图谱
        """
        try:
            # 解析GraphML文件
            tree = ET.parse(graphml_file)
            root = tree.getroot()
            
            # GraphML命名空间
            ns = {'graphml': 'http://graphml.graphdrawing.org/xmlns'}
            
            # 创建知识图谱
            graph = KnowledgeGraph(name=graph_name)
            
            # 解析节点（实体）
            entities_map = {}
            for node in root.findall('.//graphml:node', ns):
                entity = self._parse_graphml_node(node, ns)
                if entity:
                    entities_map[node.get('id')] = entity
                    graph.add_entity(entity)
            
            # 解析边（关系）
            for edge in root.findall('.//graphml:edge', ns):
                relation = self._parse_graphml_edge(edge, ns, entities_map)
                if relation:
                    graph.add_relation(relation)
            
            logger.info(f"Loaded graph from GraphML: {len(graph.entities)} entities, {len(graph.relations)} relations")
            return graph
        
        except Exception as e:
            logger.error(f"Error loading graph from GraphML file {graphml_file}: {e}")
            raise
    
    def _parse_graphml_node(self, node, ns) -> Optional[Entity]:
        """
        解析GraphML节点为实体
        
        Args:
            node: XML节点
            ns: 命名空间
            
        Returns:
            Entity: 解析的实体
        """
        try:
            node_id = node.get('id')
            entity_data = {}
            
            # 提取节点属性
            for data in node.findall('graphml:data', ns):
                key = data.get('key')
                value = data.text
                if key and value:
                    # 根据LightRAG的GraphML格式映射属性
                    if key == 'd0':  # entity_id
                        entity_data['entity_id'] = value
                    elif key == 'd1':  # entity_type
                        entity_data['entity_type'] = value
                    elif key == 'd2':  # description
                        entity_data['description'] = value
                    elif key == 'd3':  # source_id
                        entity_data['source_id'] = value
                    elif key == 'd4':  # file_path
                        entity_data['file_path'] = value
                    elif key == 'd5':  # created_at
                        entity_data['created_at'] = value
            
            # 映射实体类型
            entity_type_str = entity_data.get('entity_type', 'unknown').lower()
            entity_type = self._map_entity_type(entity_type_str)
            
            # 创建实体
            entity = Entity(
                id=node_id,
                name=entity_data.get('entity_id', node_id),
                entity_type=entity_type,
                description=entity_data.get('description', ''),
                source='lightrag',
                properties={
                    'source_id': entity_data.get('source_id', ''),
                    'file_path': entity_data.get('file_path', ''),
                    'created_at': entity_data.get('created_at', '')
                }
            )
            
            return entity
        
        except Exception as e:
            logger.error(f"Error parsing GraphML node: {e}")
            return None
    
    def _parse_graphml_edge(self, edge, ns, entities_map) -> Optional[Relation]:
        """
        解析GraphML边为关系
        
        Args:
            edge: XML边
            ns: 命名空间
            entities_map: 实体映射
            
        Returns:
            Relation: 解析的关系
        """
        try:
            source_id = edge.get('source')
            target_id = edge.get('target')
            
            if source_id not in entities_map or target_id not in entities_map:
                return None
            
            edge_data = {}
            # 提取边属性
            for data in edge.findall('graphml:data', ns):
                key = data.get('key')
                value = data.text
                if key and value:
                    if key == 'd6':  # weight
                        edge_data['weight'] = float(value)
                    elif key == 'd7':  # description
                        edge_data['description'] = value
                    elif key == 'd8':  # keywords
                        edge_data['keywords'] = value
                    elif key == 'd9':  # source_id
                        edge_data['source_id'] = value
                    elif key == 'd10':  # file_path
                        edge_data['file_path'] = value
                    elif key == 'd11':  # created_at
                        edge_data['created_at'] = value
            
            # 创建关系
            relation = Relation(
                head_entity=entities_map[source_id],
                tail_entity=entities_map[target_id],
                relation_type=RelationType.RELATED_TO,  # LightRAG通常不区分关系类型
                confidence=edge_data.get('weight', 1.0),
                source='lightrag',
                properties={
                    'description': edge_data.get('description', ''),
                    'keywords': edge_data.get('keywords', ''),
                    'source_id': edge_data.get('source_id', ''),
                    'file_path': edge_data.get('file_path', ''),
                    'created_at': edge_data.get('created_at', '')
                }
            )
            
            return relation
        
        except Exception as e:
            logger.error(f"Error parsing GraphML edge: {e}")
            return None
    
    def _map_entity_type(self, entity_type_str: str) -> EntityType:
        """
        映射实体类型字符串到EntityType枚举
        
        Args:
            entity_type_str: 实体类型字符串
            
        Returns:
            EntityType: 映射的实体类型
        """
        type_mapping = {
            'person': EntityType.PERSON,
            'organization': EntityType.ORGANIZATION,
            'location': EntityType.LOCATION,
            'concept': EntityType.CONCEPT,
            'document': EntityType.DOCUMENT,
            'keyword': EntityType.KEYWORD,
            'table': EntityType.TABLE,
            'column': EntityType.COLUMN,
            'database': EntityType.DATABASE
        }
        
        return type_mapping.get(entity_type_str.lower(), EntityType.UNKNOWN)
    
    def export_to_graphml(self, graph: KnowledgeGraph, output_path: str) -> bool:
        """
        将知识图谱导出为GraphML格式
        
        Args:
            graph: 知识图谱
            output_path: 输出文件路径
            
        Returns:
            bool: 导出是否成功
        """
        try:
            from xml.dom import minidom
            
            # 创建GraphML根元素
            root = ET.Element("graphml")
            root.set("xmlns", "http://graphml.graphdrawing.org/xmlns")
            root.set("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance")
            root.set("xsi:schemaLocation", 
                    "http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd")
            
            # 定义属性键
            keys = [
                ("d0", "node", "entity_id", "string"),
                ("d1", "node", "entity_type", "string"),
                ("d2", "node", "description", "string"),
                ("d3", "node", "source_id", "string"),
                ("d4", "node", "file_path", "string"),
                ("d5", "node", "created_at", "long"),
                ("d6", "edge", "weight", "double"),
                ("d7", "edge", "description", "string"),
                ("d8", "edge", "keywords", "string"),
                ("d9", "edge", "source_id", "string"),
                ("d10", "edge", "file_path", "string"),
                ("d11", "edge", "created_at", "long")
            ]
            
            for key_id, for_type, attr_name, attr_type in keys:
                key_elem = ET.SubElement(root, "key")
                key_elem.set("id", key_id)
                key_elem.set("for", for_type)
                key_elem.set("attr.name", attr_name)
                key_elem.set("attr.type", attr_type)
            
            # 创建图元素
            graph_elem = ET.SubElement(root, "graph")
            graph_elem.set("edgedefault", "undirected")
            
            # 添加节点
            for entity in graph.entities.values():
                node_elem = ET.SubElement(graph_elem, "node")
                node_elem.set("id", entity.id)
                
                # 添加节点属性
                data_attrs = [
                    ("d0", entity.name),
                    ("d1", entity.entity_type.value),
                    ("d2", entity.description),
                    ("d3", entity.properties.get('source_id', '')),
                    ("d4", entity.properties.get('file_path', '')),
                    ("d5", str(int(entity.created_at.timestamp())))
                ]
                
                for key, value in data_attrs:
                    if value:
                        data_elem = ET.SubElement(node_elem, "data")
                        data_elem.set("key", key)
                        data_elem.text = str(value)
            
            # 添加边
            for relation in graph.relations.values():
                edge_elem = ET.SubElement(graph_elem, "edge")
                edge_elem.set("source", relation.head_entity.id)
                edge_elem.set("target", relation.tail_entity.id)
                
                # 添加边属性
                data_attrs = [
                    ("d6", str(relation.confidence)),
                    ("d7", relation.properties.get('description', '')),
                    ("d8", relation.properties.get('keywords', '')),
                    ("d9", relation.properties.get('source_id', '')),
                    ("d10", relation.properties.get('file_path', '')),
                    ("d11", str(int(relation.created_at.timestamp())))
                ]
                
                for key, value in data_attrs:
                    if value:
                        data_elem = ET.SubElement(edge_elem, "data")
                        data_elem.set("key", key)
                        data_elem.text = str(value)
            
            # 写入文件
            rough_string = ET.tostring(root, 'unicode')
            reparsed = minidom.parseString(rough_string)
            
            with open(output_path, 'w', encoding='utf-8') as f:
                reparsed.writexml(f, indent="  ", addindent="  ", newl="\n", encoding="utf-8")
            
            logger.info(f"Graph exported to GraphML: {output_path}")
            return True
        
        except Exception as e:
            logger.error(f"Error exporting graph to GraphML: {e}")
            return False
    
    async def get_graph_statistics(self) -> Dict[str, Any]:
        """
        获取图谱统计信息
        
        Returns:
            Dict[str, Any]: 统计信息
        """
        try:
            graphml_file = self.working_dir / "graph_chunk_entity_relation.graphml"
            if not graphml_file.exists():
                return {"entities_count": 0, "relations_count": 0, "status": "no_graph"}
            
            tree = ET.parse(str(graphml_file))
            root = tree.getroot()
            
            ns = {'graphml': 'http://graphml.graphdrawing.org/xmlns'}
            
            entities_count = len(root.findall('.//graphml:node', ns))
            relations_count = len(root.findall('.//graphml:edge', ns))
            
            return {
                "entities_count": entities_count,
                "relations_count": relations_count,
                "graphml_file": str(graphml_file),
                "last_modified": datetime.fromtimestamp(graphml_file.stat().st_mtime).isoformat(),
                "status": "ready"
            }
        
        except Exception as e:
            logger.error(f"Error getting graph statistics: {e}")
            return {"entities_count": 0, "relations_count": 0, "status": "error", "error": str(e)}